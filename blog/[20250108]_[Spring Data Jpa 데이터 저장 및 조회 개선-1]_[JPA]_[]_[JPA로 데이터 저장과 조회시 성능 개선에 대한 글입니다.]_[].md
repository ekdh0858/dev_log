# 불필요한 조회 최적화 및 성능 향상 방법

## 레파지토리와 서비스 최적화

### 1. 레파지토리에서 비즈니스 로직 처리
- `@Transactional` 어노테이션을 레파지토리 메서드에 사용
- 비즈니스 로직을 레파지토리에 작성하고, 필요한 객체 ID 값을 추가로 처리

### 2. JPQL을 이용한 업데이트 쿼리 작성
- 업데이트 문을 JPQL 쿼리로 작성
- `@Modifying`과 `@Transactional` 어노테이션을 함께 사용하여 변경사항을 저장하고 적용

## 불필요한 조회 줄이기

### 엔티티 저장 최적화
- LikeEntity와 같이 복합키를 사용하는 경우, `save()` 메서드 사용 시 불필요한 조회가 발생할 수 있음
- EntityManager를 직접 사용하여 불필요한 조회를 방지:

```java
@PersistenceContext
private final EntityManager em;
// save() 대신 persist() 사용
@Transactional
public void saveLikeEntity(LikeEntity likeEntity) {
em.persist(likeEntity);
}

```

## @Transactional vs 개별 업데이트

### @Transactional 사용의 장점:
1. 코드 간결성: 엔티티 변경만으로 데이터베이스 업데이트가 가능
2. 일관성: 트랜잭션 내의 모든 작업이 원자적으로 처리

### 개별 업데이트의 장점:
1. 세밀한 제어: 필요한 필드만 선택적으로 업데이트 가능
2. 성능 최적화: 불필요한 조회나 업데이트를 줄일 수 있음

## 도메인 모델 설계 고려사항

비즈니스 로직을 엔티티에 포함시킬지, 도메인 서비스에 둘지는 상황에 따라 다름:

- **엔티티에 포함:** 해당 엔티티와 직접적으로 관련된 간단한 로직
- **도메인 서비스에 포함:** 여러 엔티티 간의 복잡한 상호작용이 필요한 로직

각 상황에 맞는 최적의 설계를 선택하여 코드의 가독성, 유지보수성, 그리고 성능을 모두 고려해야 함
