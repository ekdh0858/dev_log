# JPA 객체 생성, 삭제, 수정 시기 및 관계 매핑

## 객체 생성, 삭제, 수정 시기의 중요성
- JPA를 사용하면 객체의 **생성 시기**, **삭제 시기**, **수정 시기**를 편리하게 관리할 수 있음.
- 관련 어노테이션:
  - `@EntityListeners(AuditingEntityListener.class)`: 엔티티의 이벤트 리스너 설정.
  - `@MappedSuperclass`: 상속 구조를 활용하여 공통 속성을 정의.
  - `@EnableJpaAuditing`: JPA 감사(Auditing) 기능 활성화.

### 주의사항
- JPA의 `@Entity` 클래스는 **`@Entity`** 또는 **`@MappedSuperclass`**로 지정된 클래스만 상속 가능.

---

## 객체와 테이블의 연관 관계 차이
### 테이블의 특징:
- 한쪽에만 상대방에 대한 정보가 있어도 관계를 나타낼 수 있음.

### 객체의 특징:
- 객체는 한쪽만 상대방에 대한 정보를 가지면, 다른 한쪽에서 참조 관계를 알 수 없음.
- **객체 관계 매핑**을 위해:
  - **양방향 매핑**을 설정하거나
  - **단방향 매핑**만 조회하는 방식 사용.

---

## 1대 다 관계 매핑 (User ↔ Posts)
- 유저(User)와 글(Posts)은 **1대 다 관계**.
- 객체에서는 **양방향 매핑**이 필요:
  - User: **1대 다 관계** 설정.
  - Posts: **다대 1 관계** 설정.

### Fetch 옵션
- 관계를 정의하는 어노테이션에는 `fetch` 속성을 설정할 수 있음:
  - **Lazy Loading**: 필요한 경우에 데이터를 로딩 (`FetchType.LAZY`).
    - 기본값: `@OneToMany`.
  - **Eager Loading**: 데이터를 즉시 로딩 (`FetchType.EAGER`).
    - 기본값: `@ManyToOne`.

---

## Primary Key 설정 및 복합 키
- UserRelationEntity는 별도의 도메인이 없으며, `User`와 `UserInfo`의 `id`를 가져와 사용.
- 두 `id`를 결합하여 **복합 키(Composite Key)**로 설정.

### 복합 키 생성 방법
1. **ID 엔티티 생성 및 상속**:
   - 별도의 ID 클래스를 생성하여 필드 상속.
2. **`@EmbeddedId` 사용**:
   - ID 객체를 필드로 포함.

### 복합 키의 장점
- **PK는 클러스터드 인덱스**로 적용되므로 빠른 조회 가능.
- 별도의 인덱스 설정 없이도 고속 조회 및 **유니크 보장**.

---

## OneToMany의 한계와 주의점
- **OneToMany 기본값**: `FetchType.LAZY`.
- **ManyToOne 기본값**: `FetchType.EAGER`.

### OneToMany 문제점
1. **메모리 사용 증가**:
   - `FetchType.EAGER`로 설정 시, 데이터량이 많아질수록 메모리 부족 가능성.
2. **N+1 문제**:
   - 반복문에서 하위 데이터 조회 시, 여러 번의 쿼리 수행.
3. **페이징 처리의 어려움**:
   - 대량 데이터를 처리할 때, JPA 레포지토리에서 페이징 기능 활용이 필요.
   - 별도의 인덱스 설정이 번거로울 수 있음.

### OneToMany 사용 지양
- 반드시 필요한 경우가 아니라면 `OneToMany`를 사용하지 않는 것이 좋음.
- **대량 데이터 조회**:
  - 레포지토리를 통해 쿼리 최적화 및 페이징 처리 권장.

---

## 외래 키 사용의 실무 한계
- **DDL 생성 시 외래 키 제약 조건**:
  - 데이터의 연관 관계를 강제.
  - 하지만 **제약 조건**으로 인해:
    - 데이터 수정이 어려워짐.
    - 원치 않는 인덱스 관리 부담 발생.

### 실무에서 외래 키 지양 이유
- 외래 키를 많이 사용하지 않음.
- 대신 애플리케이션 로직에서 관계를 관리하는 방식 선호.
